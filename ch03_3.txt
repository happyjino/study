ch03_3 - 객체와 클래스

클래스 선언문
TS는 C++, Java에서 볼 수 있는 class, private, public, protected, implements, extend 같은 키워드를 제공한다.
클래스의 기본 형태
class 클래스 이름 {
  [private | protected | public] 속성 이름[?]: 속성 타입[...]
}
ex) class Person1 {
  name: string
  age?: number
}

접근 제한자(access modifier)
public, private, protected와 같은 접근 제한자를 이름 앞에 붙일 수 있다. 생략 시 public으로 간주

생성자(constructor)
TS 클래스는 constructor라는 생성자 메서드를 포함한다.
동작은 다음과 같이 한다.
ex) class Person2 {
  constructor(public name: string, public age?: number) {}
}
let jack2: Person2 = new Person2('Jack', 32);
console.log(jack2) // Person2 { name: 'Jack', age: 32 }
위처럼 생성하면서 값을 부여한다.
위의 예시에 public을 붙였기 때문에 해당 속성이 클래스에 선언된 것처럼 동작한다! 알지알지~ 좀 어렵지~

ex) class Person3 {
  name: string
  age?: number
  constructor(name: string, age?: number) {
    this.name = name; this.age = age;
  }
}
Person2랑 3는 똑같이 동작한다.

인터페이스 구현
class 클래스 이름 implements 인터페이스 이름으로 인터페이스를 구현할 수 있다.
다만 기억할 점은 인터페이스는 규약(spec)에 불과할 뿐 물리적으로 해당 속성을 만들지 않는다는 점!
그렇기 때문에 클래스 몸통에 속성을 정의해야 한다!

추상 클래스
abstract 키워드를 사용해 추상 클래스를 만들수 있다!
abstract class 클래스 이름 {
  abstract 속성 이름: 속성 타입
  abstract 메서드 이름() {}
}으로 구현한다.
추상 클래스는 자신의 속성이나 메서드 앞에 abstract를 붙여 상속하는 다른 클래스에서 속성이나 메서드를 구현하게 한다.
ex)
abstract class AbstractPerson5 {
  abstract name: string
  constructor(public age?: number) {}
}
위 예시는 name 속성 앞에 abstract가 붙었으므로 new 연산자를 적용해 객체를 만들 수 없다!! 그럼 언제 사용할까? 바로 상속!!!

클래스의 상속
객체지향 언어 특! 부모 클래스를 상속받는 상속 클래스를 만들 수 있다!
TS는 extends 키워드를 사용해 상속 클래스를 만든다.
class 상속 클래스 extends 부모 클래스 { ... }
ex)
class Person5 extends AbstractPerson5 {
  constructor(public name: string, age?: number) {
    super(age);
  }
}
위처럼 상속하고, AbstractPerson5가 구현한 age를 얻고 name을 구현한다!
super 키워드로 부모 클래스의 생성자를 호출한다!

static 속성
class 클래스 이름 {
  static 정적속성이름: 속성 타입
}으로 선언한다.
ex) class A {
  static initValue = 1
}
let initVal = A.initValue // 1
위 코드의 클래스 A는 initValue라는 정적 속성을 가진다.
클래스의 정적 속성은 클래스이름.정적속성이름 형태의 점 표기법(dot notation)을 사용해 세팅한다.
